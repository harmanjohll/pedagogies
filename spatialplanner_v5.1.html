<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spatial Pedagogy Planner (v5.6 ‚Äî Final Fixes)</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f6f7f9; --panel: #ffffff; --ink: #1f2937; --muted: #6b7280;
    --grid: #e5e7eb; --accent: #2563eb; --accent-dark: #1e40af; --accent-2: #16a34a; --accent-3: #f59e0b;
    --door: #8b5e34; --window: #93c5fd; --danger: #ef4444;
    --btn-primary-bg: #000C53; --btn-primary-text: #FFE200;
  }
  .dark {
    --bg: #111827; --panel: #1f2937; --ink: #f9fafb; --muted: #9ca3af;
    --grid: #374151; --accent: #3b82f6; --accent-dark: #60a5fa; --accent-2: #22c55e; --accent-3: #f59e0b;
    --door: #ab8259; --window: #60a5fa;
    --btn-primary-bg: #FFE200; --btn-primary-text: #000C53;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.5; transition: background-color 0.3s, color 0.3s;}
  .app{display:grid;grid-template-columns:320px 1fr 360px;gap:12px;height:100vh;padding:12px;box-sizing:border-box}
  .panel{background:var(--panel);border-radius:1rem;box-shadow:0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);padding:1.5rem;display:flex;flex-direction:column;min-height:0;overflow:auto; transition: background-color 0.3s;}
  .panel h2{margin:.25rem 0 .5rem;font-size:1.125rem; font-weight:600;}
  .section{margin-bottom:1.25rem;border-top:1px dashed var(--grid);padding-top:1.25rem}
  .section:first-of-type{border-top:none;padding-top:0}
  .chipbar{display:flex;gap:6px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--grid);border-radius:999px;padding:6px 10px;background: var(--bg);cursor:pointer;user-select:none; font-size: 13px;}
  .chip .swatch{width:14px;height:14px;border-radius:3px;border:1px solid rgba(0,0,0,.1)}
  .hint{color:var(--muted);font-size:0.75rem;margin-bottom:1rem; text-align: center;}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap}
  button{border:none;border-radius:10px;padding:12px 16px;background:#111827;color:#fff;cursor:pointer; transition: background-color 0.2s; font-weight: 500; white-space: nowrap; font-size: 13px;}
  button:hover{background:#374151;}
  button:disabled { background: #9ca3af; cursor: not-allowed; }
  /* --- FIX: Decreased font size for primary buttons --- */
  button.primary { background: var(--btn-primary-bg); color: var(--btn-primary-text); font-size: 12px; }
  button.primary:hover { background: var(--accent-dark); }
  .dark button.primary:hover { background: #d3be00; }
  button.secondary{background:#e5e7eb;color:#111827}
  button.secondary:hover{background:#d1d5db;}
  .dark button.secondary { background: #4b5563; color: #f9fafb; }
  .dark button.secondary:hover { background: #6b7280; }
  button.ghost{background:transparent;color:var(--ink);border:1px solid var(--grid)}
  button.ghost:hover{background:var(--bg);}
  button.danger{background:var(--danger)}
  button.danger:hover{background:#b91c1c;}
  label.toggle{display:flex;align-items:center;gap:8px;font-weight:500;margin:8px 0}
  select, input[type="text"], textarea{width:100%; border:1px solid var(--grid);border-radius:8px;padding:6px 8px;font:inherit; box-sizing: border-box; background: var(--bg); color: var(--ink);}
  textarea { resize: vertical; min-height: 100px; }

  /* Canvas wrapper */
  .stage-wrap{position:relative;background:var(--panel);border-radius:1rem;box-shadow:0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);padding:10px;min-height:0}
  #stage{width:100%;height:calc(100vh - 44px);background:var(--panel);border-radius:12px;-webkit-tap-highlight-color: transparent}
  .toolbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px;flex-wrap:wrap}
  .toolbar .left, .toolbar .right{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;background:var(--bg);border:1px solid var(--grid);border-radius:6px;padding:2px 6px;font-size:12px}
  .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:12px;flex-wrap:wrap}
  .legend .tag{display:inline-flex;align-items:center;gap:6px}
  .tag .swatch{width:10px;height:10px;border-radius:2px}

  .toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);background:#111827;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px;opacity:.95;display:none; z-index: 100;}
  
  /* INSIGHTS PANEL STYLES */
  .insight-group { border-left: 3px solid var(--grid); padding-left: 1rem; transition: border-color 0.3s; }
  .insight-group:hover { border-left-color: var(--accent-2); }
  .insight-title { font-size: 1rem; font-weight: 600; color: var(--ink); margin-bottom: 0.5rem; }
  .insight-subtitle { font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); margin-top: 0.75rem; margin-bottom: 0.25rem; }
  .insight-text { font-size: 0.875rem; color: var(--ink); line-height: 1.5; }
  .insight-list { list-style-type: none; padding-left: 0; font-size: 0.875rem; color: var(--ink); display: flex; flex-direction: column; gap: 0.75rem; }
  .insight-list li { position: relative; padding-left: 1.25rem; }
  .insight-list li::before { content: '‚úì'; position: absolute; left: 0; color: var(--accent-2); font-weight: 600; }
  
  .scene-list{display:flex;flex-direction:column;gap:6px;overflow:auto}
  .scene-item{display:flex;align-items:center;justify-content:space-between;border:1px solid var(--grid);border-radius:10px;padding:6px 8px}
  .scene-item input{width:100px}
  .scene-actions{display:flex;gap:6px}

  .ow-panel { cursor: grab; }
  .ghost-snap{fill:none;stroke:#6366f1;stroke-width:2;stroke-dasharray:6 6;pointer-events:none;opacity:.9}
  .ghost-snap text{fill:#6366f1;font-size:10px}
  .handle{pointer-events:all}
  .togglebox{display:flex;align-items:center;gap:8px}
  .muted{color:var(--muted)}

  .selection{pointer-events:none}
  .marquee{fill:rgba(59, 130, 246, .08); stroke:#3b82f6; stroke-dasharray:4 4; stroke-width:1; pointer-events:none}

  svg :focus{outline:none}

  .text-label-bg { stroke: var(--muted); stroke-width: 1; stroke-dasharray: 2 2; fill: rgba(243, 244, 246, 0.7); }
  .dark .text-label-bg { fill: rgba(55, 65, 81, 0.7); }
  .text-label-text { font-size: 14px; font-family: 'Inter', sans-serif; fill: var(--ink); }
  .text-edit-foreign-object { overflow: visible; }
  .text-edit-textarea {
    background: var(--panel); border: 1px solid var(--accent); color: var(--ink);
    padding: 4px; font-family: inherit; font-size: 14px;
    width: 100%; height: 100%; box-sizing: border-box; resize: none;
    border-radius: 4px;
  }
</style>
</head>
<body>
  <div class="app">
    <!-- Left Panel -->
    <aside class="panel" id="palette">
      <div class="section">
        <h2>Intelligent Assistant</h2>
        <p class="hint">Describe your lesson, and the assistant will suggest a layout.</p>
        <textarea id="llm-prompt">I am planning a lesson for [28] students. The main activity is [collaborative problem-solving in small groups] to develop [critical thinking and communication skills]. Please suggest an appropriate classroom layout.</textarea>
        <button id="llm-generate-btn" class="primary mt-2 w-full">Generate Layout</button>
      </div>

      <div class="section">
        <h2>Item Library</h2>
        <div class="hint">
          Click to add. Drag to place. <span class="kbd">Shift</span> multi-select ‚Ä¢ <span class="kbd">Drag</span> empty space = marquee select ‚Ä¢ <span class="kbd">R</span> rotate (Shift=15¬∞ / Alt=free) ‚Ä¢ <span class="kbd">Del</span> delete ‚Ä¢ Hold <span class="kbd">Alt</span> = bypass snapping.
        </div>
      </div>

      <div class="section"><strong>Furniture</strong><div class="chipbar" id="chips-furniture"></div></div>
      <div class="section"><strong>Tech</strong><div class="chipbar" id="chips-tech"></div></div>
      <div class="section"><strong>Cognitive Tools</strong><div class="chipbar" id="chips-cognitive"></div></div>
      <div class="section"><strong>Social Furniture</strong><div class="chipbar" id="chips-social"></div></div>
      <div class="section"><strong>Wellbeing Items</strong><div class="chipbar" id="chips-emotional"></div></div>
      <div class="section"><strong>Stations (coloured desks)</strong><div class="chipbar" id="chips-stations"></div></div>
      <div class="section"><strong>Zones & Annotations</strong>
        <div class="hint">Zones are overlays. Text labels are for annotation.</div>
        <div class="chipbar" id="chips-zones"></div>
      </div>

      <div class="section">
        <div class="togglebox">
          <label class="toggle"><input type="checkbox" id="toggleWall" checked> Show operable walls</label>
        </div>
        <div class="togglebox">
          <label class="toggle"><input type="checkbox" id="toggleSnap" checked> Snap enabled</label>
          <span class="muted">(hold Alt to bypass)</span>
        </div>
        <div class="togglebox">
          <label class="toggle"><input type="checkbox" id="toggleDarkMode"> üåô Dark Mode</label>
        </div>
        <div class="btnrow mt-4">
          <button id="btnExport" class="primary">Export PNG</button>
          <button class="primary" id="btnClear">Clear</button>
        </div>
        <div class="btnrow mt-2">
          <button class="primary" id="btnCloseA">Close A</button>
          <button class="primary" id="btnCloseB">Close B</button>
          <button class="primary" id="btnStackA">A: Stack 4+4</button>
          <button class="primary" id="btnStackB">B: Stack 4+4</button>
        </div>
      </div>
    </aside>

    <!-- Main Stage -->
    <main class="stage-wrap">
      <div class="toolbar">
        <div class="left legend">
          <span class="tag"><span class="swatch" style="background:#93c5fd"></span> Cognitive</span>
          <span class="tag"><span class="swatch" style="background:#a7f3d0"></span> Social</span>
          <span class="tag"><span class="swatch" style="background:#fde68a"></span> Emotional</span>
          <span class="tag"><span class="swatch" style="background:var(--door)"></span> Door / Front</span>
          <span class="tag"><span class="swatch" style="background:var(--window)"></span> Windows</span>
          <span class="tag"><span class="swatch" style="background:#9ca3af"></span> Operable wall tracks</span>
          <label class="toggle"><input type="checkbox" id="toggleLegend" checked> Legend</label>
        </div>
        <div class="right">
          <div class="togglebox">
            <label>Mode preset</label>
            <select id="presetSelect">
              <option value="">‚Äî Select preset ‚Äî</option>
              <option value="direct">Direct Instruction</option>
              <option value="pods">Group Pods (4‚Äì6)</option>
              <option value="stations">Stations / Rotations</option>
              <option value="circle">Discussion Circle / U</option>
              <option value="quiet">Quiet Work</option>
              <option value="maker">Makerspace</option>
            </select>
            <button class="ghost" id="applyPreset">Apply</button>
          </div>
          <span class="kbd">Grid: 12√ó12 (‚âà144 units)</span>
        </div>
      </div>

      <svg id="stage" viewBox="0 0 1440 720" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <pattern id="grid" width="60" height="60" patternUnits="userSpaceOnUse">
            <rect width="60" height="60" fill="var(--panel)"/>
            <path d="M60 0V60 M0 60H60" stroke="var(--grid)" stroke-width="1"/>
          </pattern>
          <filter id="elev" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#000" flood-opacity="0.25"/>
          </filter>
          <linearGradient id="deskGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#ffffff" stop-opacity="0.6"/>
            <stop offset="100%" stop-color="#000000" stop-opacity="0.05"/>
          </linearGradient>
        </defs>

        <rect id="roomA" x="0" y="0" width="720" height="720" fill="url(#grid)"/>
        <line id="trackA" x1="720" y1="0" x2="720" y2="720" stroke="#9ca3af" stroke-width="2" stroke-dasharray="6 6" opacity="0.35"/>
        <line id="trackB" x1="1080" y1="0" x2="1080" y2="720" stroke="#9ca3af" stroke-width="2" stroke-dasharray="6 6" opacity="0.35"/>
        <rect id="roomB" x="720" y="0" width="720" height="720" fill="url(#grid)" opacity="0.08" />

        <g id="items"><g id="layoutRoot"></g></g>
        
        <g id="operableWalls">
          <g id="wallA" data-x="720"></g>
          <g id="wallB" data-x="1080"></g>
        </g>

        <g id="ghost"></g>
        <rect id="marquee" class="marquee" x="0" y="0" width="0" height="0" style="display:none"/>

        <g id="shell">
          <rect x="0" y="0" width="1440" height="720" fill="none" stroke="var(--ink)" stroke-width="8"/>
          <text id="frontLabel" x="50" y="22" font-size="14" font-family="system-ui" fill="var(--ink)">FRONT</text>
          <rect id="doorTopA" x="300" y="-1" width="60" height="10" fill="var(--door)" />
          <rect id="doorTopB" x="1000" y="-1" width="60" height="10" fill="var(--door)" />
          
          <rect id="winTop1" x="130" y="-1" width="560" height="10" fill="var(--window)" />
          <rect id="winTop2" x="780" y="-1" width="560" height="10" fill="var(--window)" />
          <rect id="winBot1" x="130" y="711" width="560" height="10" fill="var(--window)" />
          <rect id="winBot2" x="780" y="711" width="560" height="10" fill="var(--window)" />
        </g>
      </svg>

      <div class="toast" id="toast"></div>
    </main>

    <!-- Right Panel: Insights + Scenes -->
    <aside class="panel">
        <div class="section">
            <h2>Spatial Effectiveness Profile</h2>
            <canvas id="spatialEffectivenessChart"></canvas>
        </div>
        <div class="section" id="pedagogyInsights">
            <h2>Pedagogical Opportunities</h2>
            <div id="insightsContainer" class="flex flex-col gap-6">
                <!-- Qualitative insights will be dynamically generated here -->
            </div>
        </div>
        
        <div class="section">
            <h2>Scenes (Lesson Timeline)</h2>
            <div class="btnrow">
                <input id="sceneName" type="text" placeholder="Scene name (e.g., Warm-up)">
                <button id="saveScene" class="primary">Save current</button>
            </div>
            <div class="scene-list mt-2" id="sceneList"></div>
        </div>
    </aside>
  </div>

<script>
(function(){
  // --- DOM ELEMENT REFERENCES ---
  const unit = 60;
  const stage = document.getElementById('stage');
  const itemsLayer = document.getElementById('items');
  const layoutRoot = document.getElementById('layoutRoot');
  const operableWallsLayer = document.getElementById('operableWalls');
  const ghostLayer = document.getElementById('ghost');
  const marquee = document.getElementById('marquee');
  const toast = document.getElementById('toast');
  const insightsContainer = document.getElementById('insightsContainer');
  const wallAG = document.getElementById('wallA');
  const wallBG = document.getElementById('wallB');
  
  // Toggles
  const toggleWall = document.getElementById('toggleWall');
  const toggleSnap = document.getElementById('toggleSnap');
  const toggleLegend = document.getElementById('toggleLegend');
  const toggleDarkMode = document.getElementById('toggleDarkMode');

  // Buttons
  const btnExport = document.getElementById('btnExport');
  const btnClear = document.getElementById('btnClear');
  const applyPresetBtn = document.getElementById('applyPreset');
  
  // Scene Controls
  const sceneName = document.getElementById('sceneName');
  const saveSceneBtn = document.getElementById('saveScene');
  const sceneList = document.getElementById('sceneList');
  
  // LLM Controls
  const llmPromptEl = document.getElementById('llm-prompt');
  const llmGenerateBtn = document.getElementById('llm-generate-btn');

  // --- STATE VARIABLES ---
  let spatialChart = null;
  let scenes = [];
  const selected = new Set();
  let SNAP_RADIUS = unit * 0.35;
  let NEIGHBOR_RADIUS = unit * 1.7;
  let ANGLE_HYSTERESIS = 12;

  // --- CONSTANTS ---
  const TRI_S = unit * 0.98;
  const TRI_H = Math.sin(Math.PI/3) * TRI_S;
  const PANEL_COUNT = 8;
  const PANEL_THICKNESS = 10;
  let panelState = { A: [], B: [] };

  // --- ITEM PALETTE DEFINITION ---
  const PALETTE = [
    {cat:'furniture', id:'desk_rect', label:'Desk (rect)', draw:(g,o)=>deskRect(g,{...o,w:unit*1.0,h:unit*0.7,base:'#e5e7eb'}), snap:'edge90'},
    {cat:'furniture', id:'desk_round', label:'Table (round)', draw:(g,o)=>roundTable(g,{...o,r:unit*0.55,base:'#d1fae5'}), snap:'none'},
    {cat:'furniture', id:'desk_trap', label:'Desk (trapezoid)', draw:(g,o)=>trapDesk(g,{...o,w:unit*1.0,h:unit*0.7,base:'#fee2e2'}), snap:'edge60'},
    {cat:'furniture', id:'desk_tri_eq', label:'Desk (triangle)', draw:(g,o)=>triDesk(g,{...o,s:TRI_S,base:'#e0f2fe'}), snap:'tri60'},
    {cat:'furniture', id:'chair', label:'Chair', draw:(g,o)=>chair(g,{...o,w:unit*0.55,h:unit*0.55}), snap:'none'},
    {cat:'furniture', id:'stand_table', label:'Standing table (long)', draw:(g,o)=>deskRect(g,{...o,w:unit*2.4,h:unit*0.6,base:'#fde68a'}), snap:'edge90'},
    {cat:'tech', id:'writable_tv', label:'Writable TV', draw:(g,o)=>tv(g,{...o,w:unit*1.6,h:unit*0.9}), snap:'edge90'},
    {cat:'tech', id:'vr_station', label:'VR Station', draw:(g,o)=>vr(g,{...o,r:unit*0.5}), snap:'none'},
    {cat:'tech', id:'tablet_cart', label:'Tablet Cart', draw:(g,o)=>cart(g,{...o,w:unit*0.9,h:unit*0.7}), snap:'none'},
    {cat:'cognitive', id:'whiteboard', label:'Mobile Whiteboard', draw:(g,o)=>board(g,{...o,w:unit*1.1,h:unit*1.6,base:'#93c5fd'}), snap:'edge90'},
    {cat:'cognitive', id:'teacher_desk', label:'Teacher Desk', draw:(g,o)=>deskRect(g,{...o,w:unit*1.6,h:unit*0.8,base:'#bfdbfe'}), snap:'edge90'},
    {cat:'social', id:'group_table', label:'Group Table (6)', draw:(g,o)=>roundTable(g,{...o,r:unit*0.8,base:'#a7f3d0'}), snap:'none'},
    {cat:'social', id:'partition', label:'Mobile Partition', draw:(g,o)=>partition(g,{...o,w:unit*0.3,h:unit*1.8,base:'#34d399'}), snap:'edge90'},
    {cat:'emotional', id:'couch', label:'Couch', draw:(g,o)=>couch(g,{...o,w:unit*1.8,h:unit*0.8,base:'#fdba74'}), snap:'edge90'},
    {cat:'emotional', id:'beanbag', label:'Beanbag', draw:(g,o)=>beanbag(g,{...o,r:unit*0.55,base:'#fde68a'}), snap:'none'},
    {cat:'emotional', id:'plant', label:'Plant', draw:(g,o)=>plant(g,{...o,r:unit*0.45}), snap:'none'},
    {cat:'stations', id:'desk_blue', label:'Desk (Blue)', draw:(g,o)=>deskRect(g,{...o,w:unit*1.0,h:unit*0.7,base:'#bfdbfe'}), snap:'edge90'},
    {cat:'stations', id:'desk_green', label:'Desk (Green)', draw:(g,o)=>deskRect(g,{...o,w:unit*1.0,h:unit*0.7,base:'#bbf7d0'}), snap:'edge90'},
    {cat:'stations', id:'desk_orange', label:'Desk (Orange)', draw:(g,o)=>deskRect(g,{...o,w:unit*1.0,h:unit*0.7,base:'#fed7aa'}), snap:'edge90'},
    {cat:'zones', id:'text_label', label:'Text Label', draw:(g,o)=>textLabel(g,{...o,w:unit*2, h:unit*0.8, text:'Double-click to edit'}), resizable:true},
    {cat:'zones', id:'zone_cog', label:'Zone: Cognitive', draw:(g,o)=>zone(g,{...o,w:unit*3,h:unit*2,base:'#93c5fd',label:'Cognitive'}), resizable:true},
    {cat:'zones', id:'zone_soc', label:'Zone: Social', draw:(g,o)=>zone(g,{...o,w:unit*3,h:unit*2,base:'#a7f3d0',label:'Social'}), resizable:true},
    {cat:'zones', id:'zone_emo', label:'Zone: Emotional', draw:(g,o)=>zone(g,{...o,w:unit*3,h:unit*2,base:'#fde68a',label:'Emotional'}), resizable:true},
  ];

  // --- HELPER FUNCTIONS ---
  const snap = v => Math.round(v/unit)*unit;
  const deg = r => r*180/Math.PI;
  const rad = d => d*Math.PI/180;
  const normAngle = a => (a % 360 + 360) % 360;
  function getMouseSVG(evt){ const p = stage.createSVGPoint(); p.x = evt.clientX; p.y = evt.clientY; return p.matrixTransform(stage.getScreenCTM().inverse()); }
  function getTranslate(g){ const tr = g.getAttribute('transform')||''; const m = /translate\(([-0-9.]+),\s*([-0-9.]+)\)/.exec(tr); return m ? [parseFloat(m[1]), parseFloat(m[2])] : [0,0]; }
  function getRotate(g){ const tr = g.getAttribute('transform')||''; const m = /rotate\(([-0-9.]+)\)/.exec(tr); return m ? parseFloat(m[1]) : 0; }
  function flash(msg){ toast.textContent = msg; toast.style.display='block'; clearTimeout(flash._t); flash._t=setTimeout(()=> toast.style.display='none', 1600); }

  // --- INITIALIZATION ---
  function initializeApp() {
    populatePalette();
    initializeChart();
    buildOperableWalls();
    closeWall('A');
    closeWall('B');
    setupEventListeners();
    checkDarkMode();
    updateMetrics();
  }

  function populatePalette() {
    const mapCatToEl = {
      furniture: document.getElementById('chips-furniture'), tech: document.getElementById('chips-tech'),
      cognitive: document.getElementById('chips-cognitive'), social: document.getElementById('chips-social'),
      emotional: document.getElementById('chips-emotional'), stations: document.getElementById('chips-stations'),
      zones: document.getElementById('chips-zones')
    };
    PALETTE.forEach(item=>{
      const chip = document.createElement('div'); chip.className='chip';
      const sw = document.createElement('span'); sw.className='swatch';
      if (item.id === 'text_label') {
        sw.textContent = 'T'; sw.style.fontWeight = 'bold'; sw.style.textAlign = 'center'; sw.style.lineHeight = '14px';
      } else {
        sw.style.background=(item.id.includes('desk_')? (item.id.includes('blue')?'#bfdbfe':item.id.includes('green')?'#bbf7d0':item.id.includes('orange')?'#fed7aa':'#e5e7eb') : (item.cat==='cognitive'?'#93c5fd':item.cat==='social'?'#a7f3d0':item.cat==='emotional'?'#fde68a':'#e5e7eb'));
      }
      chip.appendChild(sw); chip.append(item.label);
      chip.addEventListener('click',()=> addItem(item));
      mapCatToEl[item.cat].appendChild(chip);
    });
  }

  // --- SELECTION MANAGEMENT ---
  function drawSelection(){ itemsLayer.querySelectorAll('.selection').forEach(n=>n.remove()); operableWallsLayer.querySelectorAll('.selection').forEach(n=>n.remove()); selected.forEach(g=>{ const bb = g.getBBox(); const r = document.createElementNS('http://www.w3.org/2000/svg','rect'); r.classList.add('selection'); r.setAttribute('x', bb.x-6); r.setAttribute('y', bb.y-6); r.setAttribute('width', bb.width+12); r.setAttribute('height', bb.height+12); r.setAttribute('rx',6); r.setAttribute('ry',6); r.setAttribute('fill','none'); r.setAttribute('stroke','var(--accent)'); r.setAttribute('stroke-width','2'); r.setAttribute('vector-effect','non-scaling-stroke'); r.setAttribute('pointer-events','none'); g.insertBefore(r, g.firstChild); }); }
  function clearSelection(){ selected.clear(); itemsLayer.querySelectorAll('.selection').forEach(n=>n.remove()); operableWallsLayer.querySelectorAll('.selection').forEach(n=>n.remove()); removeHandles(); }
  
  // --- ITEM MANIPULATION ---
  function addItem(def){ 
    const wrapper = document.createElementNS('http://www.w3.org/2000/svg','g'); 
    wrapper.setAttribute('data-id', def.id); 
    wrapper.setAttribute('data-snap', def.snap || 'none'); 
    if(def.resizable) wrapper.setAttribute('data-resizable','1'); 
    wrapper.setAttribute('transform', `translate(${unit*2},${unit*2}) rotate(0)`); 
    wrapper.style.cursor='move'; 
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); 
    def.draw(g,{x:0,y:0}); 
    wrapper.appendChild(g); 
    layoutRoot.appendChild(wrapper); 
    makeDraggable(wrapper); 

    if (def.id === 'text_label') {
        wrapper.addEventListener('dblclick', editTextLabel);
    }

    clearSelection(); 
    selected.add(wrapper); 
    drawSelection(); 
    flash('Tip: Hold Alt to bypass snapping'); 
    updateMetrics(); 
  }

  function makeDraggable(g){ let offset = {x:0,y:0}, dragging=false, groupStart=null; g.addEventListener('pointerdown', e=>{ e.stopPropagation(); dragging=true; g.setPointerCapture(e.pointerId); if(!e.shiftKey && !selected.has(g)){ clearSelection(); selected.add(g); drawSelection(); } const {x,y} = getMouseSVG(e); groupStart = [...selected].map(node=>({ node, t:getTranslate(node) })); const meStart = groupStart.find(s=>s.node===g).t; offset = {x:x-meStart[0], y:y-meStart[1]}; }); g.addEventListener('pointermove', e=>{ if(!dragging) return; const {x,y} = getMouseSVG(e); const bypass = e.altKey || !toggleSnap.checked; let nx = x - offset.x, ny = y - offset.y; if(!bypass){ nx = snap(nx); ny = snap(ny); } const meStart = groupStart.find(s=>s.node===g).t; const dx = nx - meStart[0], dy = ny - meStart[1]; groupStart.forEach(s=>{ let px = s.t[0] + dx, py = s.t[1] + dy;
    px = Math.max(0, Math.min(px, 1440 - unit)); py = Math.max(0, Math.min(py, 720 - unit)); const r = getRotate(s.node); s.node.setAttribute('transform', `translate(${px},${py}) rotate(${r})`); }); if(selected.size===1){ if(!bypass) trySnap(g, true); else clearGhost(); }else{ clearGhost(); } drawSelection(); }); g.addEventListener('pointerup', e=>{ dragging=false; try{ g.releasePointerCapture(e.pointerId);}catch(_){ } if(selected.size===1){ const bypass = e.altKey || !toggleSnap.checked; if(!bypass) trySnap(g, false); } clearGhost(); updateMetrics(); }); }
  
  function centroidOfSelection(){ const arr=[...selected]; if(arr.length===0) return null; const pts = arr.map(n=>getTranslate(n)); const cx = pts.reduce((a,p)=>a+p[0],0)/pts.length; const cy = pts.reduce((a,p)=>a+p[1],0)/pts.length; return {cx, cy}; }
  
  function rotateSelection(useFine, isAltPressed){ 
    if(selected.size===0) return; 
    
    const step = isAltPressed ? 1 : (useFine ? 15 : 45); 
    
    if(selected.size===1){ 
        const node=[...selected][0]; 
        const [tx,ty]=getTranslate(node); 
        let currentRot = getRotate(node);
        let nextRot = currentRot + step;
        
        if(!isAltPressed && toggleSnap.checked){ 
            const mode = node.getAttribute('data-snap'); 
            if(mode==='tri60' || mode==='edge60'){ 
                nextRot = Math.round(nextRot/60)*60; 
            } else if(mode==='edge90'){ 
                const n = Math.round(nextRot/90)*90; 
                if(Math.abs(n-nextRot) <= ANGLE_HYSTERESIS) nextRot = n; 
            } 
        } 
        node.setAttribute('transform', `translate(${tx},${ty}) rotate(${normAngle(nextRot)})`); 
        drawSelection(); 
        updateMetrics(); 
        return; 
    } 
    
    const C = centroidOfSelection(); 
    if(!C) return; 
    const theta = rad(step); 
    const sinT = Math.sin(theta), cosT = Math.cos(theta); 
    [...selected].forEach(node=>{ 
        const [tx,ty] = getTranslate(node); 
        const vx = tx - C.cx, vy = ty - C.cy; 
        const rx = vx * cosT - vy * sinT; 
        const ry = vx * sinT + vy * cosT; 
        const newX = C.cx + rx, newY = C.cy + ry; 
        const newRot = getRotate(node) + step; 
        node.setAttribute('transform', `translate(${newX},${newY}) rotate(${normAngle(newRot)})`); 
    }); 
    drawSelection(); 
    updateMetrics(); 
  }

  // --- OPERABLE WALLS ---
  function buildOperableWalls(){
    wallAG.innerHTML = ''; wallBG.innerHTML = '';
    panelState = { A: [], B: [] };
    [{g:wallAG,x:720,id:'A'},{g:wallBG,x:1080,id:'B'}].forEach(({g,x,id})=>{
      for(let i=0;i<PANEL_COUNT;i++){
        const panel = document.createElementNS('http://www.w3.org/2000/svg','g');
        panel.classList.add('ow-panel');
        panel.setAttribute('data-id', `ow-panel-${id}-${i}`);
        panel.setAttribute('data-track', x);
        const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
        r.setAttribute('rx',2); r.setAttribute('fill','#dbeafe'); r.setAttribute('stroke','var(--ink)'); r.setAttribute('stroke-width','1'); r.setAttribute('filter','url(#elev)');
        panel.appendChild(r); g.appendChild(panel);
        panelState[id].push({ node: panel });
        makeWallPanelDraggable(panel);
      }
    });
  }
  
  function closeWall(which){
    const arr = panelState[which];
    const x = which === 'A' ? 720 : 1080;
    const segmentH = (720 - (PANEL_COUNT - 1) * 2) / PANEL_COUNT;
    arr.forEach((st, i) => {
        const y = (segmentH / 2) + (i * (segmentH + 2));
        st.node.setAttribute('transform', `translate(${x},${y}) rotate(0)`);
        const rect = st.node.querySelector('rect');
        rect.setAttribute('width', PANEL_THICKNESS);
        rect.setAttribute('height', segmentH);
        rect.setAttribute('x', -PANEL_THICKNESS / 2);
        rect.setAttribute('y', -segmentH / 2);
    });
    updateMetrics();
  }

  function stackWall(which, topCount = 4){
    const arr = panelState[which];
    const x = which === 'A' ? 720 : 1080;
    const segmentH = (720 - (PANEL_COUNT - 1) * 2) / PANEL_COUNT;
    
    arr.forEach((st, i) => {
        const rect = st.node.querySelector('rect');
        rect.setAttribute('width', segmentH);
        rect.setAttribute('height', PANEL_THICKNESS);
        rect.setAttribute('x', -segmentH / 2);
        rect.setAttribute('y', -PANEL_THICKNESS / 2);
        
        let y;
        if (i < topCount) {
            y = 10 + (i * (PANEL_THICKNESS + 4));
        } else {
            y = 720 - 10 - ((PANEL_COUNT - i) * (PANEL_THICKNESS + 4));
        }
        st.node.setAttribute('transform', `translate(${x}, ${y}) rotate(90)`);
    });
    updateMetrics();
  }

  function makeWallPanelDraggable(g) {
    let offset = {y:0}, dragging=false, startRot = 0;
    g.addEventListener('pointerdown', e => {
        e.stopPropagation(); dragging = true;
        g.setPointerCapture(e.pointerId);
        if(!e.shiftKey && !selected.has(g)){ clearSelection(); selected.add(g); drawSelection(); }
        const {y} = getMouseSVG(e);
        const [, ty] = getTranslate(g);
        startRot = getRotate(g); // **FIX:** Remember rotation on drag start
        offset = {y: y - ty};
    });
    g.addEventListener('pointermove', e => {
        if (!dragging) return;
        const {y} = getMouseSVG(e);
        const trackX = +g.getAttribute('data-track');
        let ny = y - offset.y;
        
        const rect = g.querySelector('rect');
        const h = startRot === 0 ? +rect.getAttribute('height') : +rect.getAttribute('width');
        
        ny = Math.max(h/2, Math.min(ny, 720 - h/2));
        
        g.setAttribute('transform', `translate(${trackX},${ny}) rotate(${startRot})`); // **FIX:** Re-apply original rotation
        drawSelection();
    });
    g.addEventListener('pointerup', e => {
        dragging = false;
        try { g.releasePointerCapture(e.pointerId); } catch(_) {}
        updateMetrics();
    });
  }

  // --- EVENT LISTENERS SETUP ---
  function setupEventListeners() {
    // Stage interaction
    stage.addEventListener('pointerdown', handleStagePointerDown);
    stage.addEventListener('pointermove', handleStagePointerMove);
    stage.addEventListener('pointerup', handleStagePointerUp);
    stage.addEventListener('pointerleave', clearGhost);

    // Keyboard interaction
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', e => { if(e.key==='Alt') rotateSelection._lastAlt = false; });

    // UI Controls
    toggleWall.addEventListener('change', ()=>{ const show = toggleWall.checked; operableWallsLayer.setAttribute('opacity', show? '1':'0'); document.getElementById('trackA').setAttribute('opacity', show? '0.35':'0'); document.getElementById('trackB').setAttribute('opacity', show? '0.35':'0'); });
    toggleSnap.addEventListener('change', ()=> { flash(toggleSnap.checked ? 'Snap ON' : 'Snap OFF'); });
    toggleLegend.addEventListener('change', ()=>{ const show = toggleLegend.checked; const shell = document.getElementById('shell'); shell.querySelectorAll('text,rect[id^="win"],rect[id^="door"]').forEach(n=>n.setAttribute('opacity', show? '1':'0')); });
    toggleDarkMode.addEventListener('change', () => {
        document.documentElement.classList.toggle('dark', toggleDarkMode.checked);
        localStorage.setItem('darkMode', toggleDarkMode.checked);
        spatialChart.destroy();
        initializeChart();
        updateMetrics();
    });

    // Buttons
    btnExport.addEventListener('click', exportPNG);
    btnClear.addEventListener('click', ()=>{ layoutRoot.innerHTML=''; clearSelection(); removeHandles(); buildOperableWalls(); closeWall('A'); closeWall('B'); updateMetrics(); });
    document.getElementById('btnCloseA').onclick = ()=> closeWall('A');
    document.getElementById('btnCloseB').onclick = ()=> closeWall('B');
    document.getElementById('btnStackA').onclick = ()=> stackWall('A',4);
    document.getElementById('btnStackB').onclick = ()=> stackWall('B',4);
    applyPresetBtn.addEventListener('click', ()=>{ const v = document.getElementById('presetSelect').value; if(!v) return; applyPreset(v, 28); updateMetrics(); });
    saveSceneBtn.addEventListener('click', saveScene);
    llmGenerateBtn.addEventListener('click', generateLayoutFromLLM);
  }

  // --- EVENT HANDLER LOGIC ---
  let marqueeActive=false, marqueeStart=null;
  function handleStagePointerDown(e) {
    const isOnItem = !!e.target.closest('g[data-id]');
    if (isOnItem) {
        const targetG = e.target.closest('g[data-id]');
        const isWall = targetG.getAttribute('data-id')?.startsWith('ow-panel');

        if (e.shiftKey) {
            // **FIX:** Prevent adding wall panels to a group that has furniture
            const hasFurniture = [...selected].some(n => !n.getAttribute('data-id')?.startsWith('ow-panel'));
            if (isWall && hasFurniture) {
                flash("Wall panels cannot be grouped with furniture.");
                return;
            }
            if (selected.has(targetG)) selected.delete(targetG);
            else selected.add(targetG);
        } else {
            if (!selected.has(targetG)) {
                clearSelection();
                selected.add(targetG);
            }
        }
        if (selected.size === 1 && targetG.getAttribute('data-resizable') === '1') showHandles(targetG);
        else removeHandles();
        drawSelection();
    } else {
        if (!e.shiftKey) { clearSelection(); removeHandles(); }
        marqueeActive = true;
        marqueeStart = getMouseSVG(e);
        marquee.setAttribute('x', marqueeStart.x); marquee.setAttribute('y', marqueeStart.y);
        marquee.setAttribute('width', 0); marquee.setAttribute('height', 0);
        marquee.style.display = 'block';
    }
  }
  function handleStagePointerMove(e) {
    if(!marqueeActive) return; 
    const cur=getMouseSVG(e); 
    const x=Math.min(cur.x,marqueeStart.x), y=Math.min(cur.y,marqueeStart.y); 
    const w=Math.abs(cur.x-marqueeStart.x), h=Math.abs(cur.y-marqueeStart.y); 
    marquee.setAttribute('x',x); marquee.setAttribute('y',y); 
    marquee.setAttribute('width',w); marquee.setAttribute('height',h);
  }
  function handleStagePointerUp(e) {
    if(!marqueeActive) return; 
    marqueeActive=false; marquee.style.display='none'; 
    const mx=+marquee.getAttribute('x'), my=+marquee.getAttribute('y'), mw=+marquee.getAttribute('width'), mh=+marquee.getAttribute('height'); 
    const box={x:mx,y:my,w:mw,h:mh}; 
    const itemsInBox = [...layoutRoot.querySelectorAll('g[data-id]'), ...operableWallsLayer.querySelectorAll('g[data-id]')].filter(g => {
        const [tx, ty] = getTranslate(g);
        return tx >= box.x && tx <= box.x + box.w && ty >= box.y && ty <= box.y + box.h;
    });

    // **FIX:** Check for mixed selection (walls + furniture)
    const hasWall = itemsInBox.some(g => g.getAttribute('data-id')?.startsWith('ow-panel'));
    const hasFurniture = itemsInBox.some(g => !g.getAttribute('data-id')?.startsWith('ow-panel'));

    if (hasWall && hasFurniture) {
        flash("Wall panels cannot be grouped with furniture.");
        itemsInBox.forEach(g => {
            if (!g.getAttribute('data-id')?.startsWith('ow-panel')) {
                selected.add(g);
            }
        });
    } else {
        itemsInBox.forEach(g => selected.add(g));
    }
    drawSelection();
  }

  function handleKeyDown(e) {
    if(['TEXTAREA', 'INPUT'].includes(document.activeElement.tagName)) return;
    if(e.key==='Alt') rotateSelection._lastAlt = true;
    if(e.key.toLowerCase()==='r'){
      if (selected.size === 1) {
          const node = [...selected][0];
          if (node.getAttribute('data-id')?.startsWith('ow-panel')) {
              const [tx, ty] = getTranslate(node);
              const currentRot = getRotate(node);
              const nextRot = (currentRot === 0) ? 90 : 0;
              node.setAttribute('transform', `translate(${tx},${ty}) rotate(${nextRot})`);
              const rect = node.querySelector('rect');
              const w = +rect.getAttribute('width');
              const h = +rect.getAttribute('height');
              rect.setAttribute('width', h);
              rect.setAttribute('height', w);
              rect.setAttribute('x', -h/2);
              rect.setAttribute('y', -w/2);
              drawSelection(); updateMetrics();
              return;
          }
      }
      rotateSelection(e.shiftKey, e.altKey);
    }
    if((e.key==='Delete' || e.key==='Backspace') && selected.size){ selected.forEach(n=>n.remove()); clearSelection(); updateMetrics(); }
    if(selected.size && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){ 
      e.preventDefault(); 
      const step = e.altKey ? 5 : (e.shiftKey ? unit : 15);
      [...selected].forEach(node=>{ 
          let [tx,ty]=getTranslate(node);
          const isWall = node.getAttribute('data-id')?.startsWith('ow-panel');
          
          if(e.key==='ArrowUp') ty -= step; 
          if(e.key==='ArrowDown') ty += step; 
          if(e.key==='ArrowLeft' && !isWall) tx -= step; 
          if(e.key==='ArrowRight' && !isWall) tx += step;

          tx = Math.max(0, Math.min(tx, 1440 - unit)); 
          ty = Math.max(0, Math.min(ty, 720 - unit)); 
          const r = getRotate(node); 
          node.setAttribute('transform', `translate(${tx},${ty}) rotate(${r})`); 
      }); 
      drawSelection(); 
      updateMetrics(); 
    }
  }

  // --- METRICS & INSIGHTS CALCULATION ---
  function updateMetrics(){
    const furnitureItems = [...layoutRoot.querySelectorAll('g[data-id]')];
    
    const isWallAOpen = panelState.A.some(p => getRotate(p.node) === 90);
    const isWallBOpen = panelState.B.some(p => getRotate(p.node) === 90);

    let totalWidth = 720; 
    if (isWallAOpen) totalWidth += 360; 
    if (isWallBOpen) totalWidth += 360; 
    const roomArea = totalWidth * 720;

    const desks = furnitureItems.filter(n=>/desk_/.test(n.getAttribute('data-id')) || ['chair'].includes(n.getAttribute('data-id')));
    const itemIds = new Set(furnitureItems.map(n => n.getAttribute('data-id')));
    const pos = g => getTranslate(g);
    const count = (id) => furnitureItems.filter(i => i.getAttribute('data-id') === id).length;

    let sightlineScore = 20;
    const teachingPoints = furnitureItems
      .filter(i => ['teacher_desk', 'writable_tv', 'whiteboard'].includes(i.getAttribute('data-id')))
      .map(tp => { const [x,y] = pos(tp); return {x, y}; });
    if (teachingPoints.length === 0) teachingPoints.push({x: 720, y: 10}); 

    if (desks.length > 0) {
        let goodSightlines = 0;
        desks.forEach(desk => {
            const [dx, dy] = pos(desk);
            const deskAngle = rad(getRotate(desk) + 90); 
            const facingVec = { x: Math.cos(deskAngle), y: Math.sin(deskAngle) };
            let closestDist = Infinity;
            let bestTP = teachingPoints[0];
            teachingPoints.forEach(tp => {
                const dist = Math.hypot(tp.x - dx, tp.y - dy);
                if (dist < closestDist) {
                    closestDist = dist;
                    bestTP = tp;
                }
            });
            const toTpVec = { x: bestTP.x - dx, y: bestTP.y - dy };
            const magToTp = Math.sqrt(toTpVec.x**2 + toTpVec.y**2);
            if (magToTp === 0) return;
            const dotProduct = (facingVec.x * toTpVec.x + facingVec.y * toTpVec.y);
            const angleDiff = Math.acos(dotProduct / magToTp); 
            if (deg(angleDiff) < 45) { 
                goodSightlines++;
            }
        });
        sightlineScore = 20 + Math.round((goodSightlines / desks.length) * 80);
    }

    let occupiedArea = furnitureItems.reduce((acc, n) => { const b = n.getBBox(); return acc + (b.width * b.height); }, 0);
    const mobilityScore = Math.max(0, Math.min(100, (1 - (occupiedArea / roomArea)) * 150 - 10));

    // **FIX:** New Density Calculation
    const studentCapacity = desks.length;
    let densityScore = 50; // Default for empty room
    if (studentCapacity > 0) {
        const areaPerStudent = roomArea / studentCapacity;
        // Map area per student to a 10-100 score. Clamp values to prevent extremes.
        const minArea = 12000; // Too crowded
        const maxArea = 45000; // Very spacious
        const clampedArea = Math.max(minArea, Math.min(areaPerStudent, maxArea));
        // Linear scale: (value - min) / (max - min)
        densityScore = 10 + ((clampedArea - minArea) / (maxArea - minArea)) * 90;
    }
    
    const furnitureTypes = new Set(PALETTE.filter(p => itemIds.has(p.id) && p.cat === 'furniture').map(p => p.id));
    const mobileItems = ['whiteboard', 'partition', 'chair', 'beanbag', 'tablet_cart'];
    const mobileItemCount = mobileItems.reduce((sum, id) => sum + count(id), 0);
    const flexibilityScore = 20 + Math.min(80, (furnitureTypes.size * 5) + (furnitureItems.length > 0 ? (mobileItemCount / furnitureItems.length) * 50 : 0));

    let inCluster=0; desks.forEach((d,i)=>{ for(let j=i+1;j<desks.length;j++){ if(Math.hypot(pos(d)[0]-pos(desks[j])[0], pos(d)[1]-pos(desks[j])[1]) <= unit*1.5){ inCluster++; break; } } });
    const clusterRatio = desks.length > 0 ? inCluster / desks.length : 0;
    
    let modalityScore = 10;
    if (clusterRatio > 0.5) modalityScore += 30; // Major bonus for collaboration
    if (itemIds.has('writable_tv') || itemIds.has('whiteboard')) modalityScore += 25;
    if (itemIds.has('group_table')) modalityScore += 15;
    if (itemIds.has('stand_table')) modalityScore += 15;
    if (itemIds.has('couch') || itemIds.has('beanbag')) modalityScore += 10;
    if (furnitureItems.some(i => i.getAttribute('data-id').startsWith('zone_'))) modalityScore += 15;
    modalityScore = Math.min(100, modalityScore);

    const plantCount = count('plant');
    let lightScore = 0;
    if (desks.length > 0) {
        const desksNearWindow = desks.filter(d => pos(d)[1] < unit * 2 || pos(d)[1] > 720 - (unit * 2)).length;
        lightScore = (desksNearWindow / desks.length) * 50;
    }
    const environmentalScore = 20 + Math.min(80, (plantCount * 15) + lightScore);

    if (spatialChart) {
        spatialChart.data.datasets[0].data = [sightlineScore, mobilityScore, flexibilityScore, densityScore, modalityScore, environmentalScore].map(s => Math.round(s));
        spatialChart.update();
    }
    updateInsights(furnitureItems, desks, clusterRatio);
  }

  function updateInsights(furnitureItems, desks, clusterRatio) {
    const itemIds = new Set(furnitureItems.map(n => n.getAttribute('data-id')));
    const hasAny = (ids) => ids.some(id => itemIds.has(id));
    const zones = furnitureItems.filter(n=>n.getAttribute('data-resizable')==='1');
    const furnitureTypes = new Set(PALETTE.filter(p => itemIds.has(p.id) && p.cat === 'furniture').map(p => p.id));
    
    let insights = [];
    let collabAffordance = "This layout is primarily for individual work, with limited opportunities for spontaneous peer discussion.";
    let collabMoves = ["Use 'Think-Pair-Share' where students turn to their nearest neighbour to discuss a prompt before sharing.", "Encourage digital collaboration using shared documents or online forums to bridge physical distances."];
    if (clusterRatio > 0.6 || hasAny(['group_table', 'desk_tri_eq'])) {
        collabAffordance = "The clustered arrangement strongly supports group work, creating natural 'pods' for discussion, peer teaching, and co-construction of knowledge.";
        collabMoves = ["<b>Facilitate Group Inquiry (STP):</b> Use a 'Jigsaw' activity where each pod becomes an expert on one topic before re-grouping to share.", "<b>Provide Timely Feedback (STP):</b> Circulate among pods to listen in on discussions and provide targeted feedback."];
    } else if (clusterRatio > 0.2) {
        collabAffordance = "This balanced arrangement allows for both individual focus and easy pairing without significant furniture rearrangement.";
        collabMoves = ["<b>Cultivate a Positive Classroom Culture (STP):</b> Design tasks that require partner work, encouraging students to learn from diverse perspectives.", "Use 'Numbered Heads Together' to ensure both individual accountability and group collaboration."];
    }
    insights.push({ title: 'ü§ù Communication & Collaboration', affordance: collabAffordance, moves: collabMoves });

    let agencyAffordance = "A uniform furniture setup provides a structured and predictable environment, suitable for teacher-led activities.";
    let agencyMoves = ["Provide choice in how students demonstrate learning (e.g., written report, presentation) even if the physical space is fixed.", "Allow students to briefly personalize their own desk space to foster a sense of ownership."];
    if (zones.length > 0 || furnitureTypes.size > 4 || hasAny(['couch', 'beanbag', 'stand_table'])) {
        agencyAffordance = "A variety of furniture types and designated zones empowers students with choice over where and how they learn, fostering agency and self-regulation.";
        agencyMoves = ["<b>Practice Differentiated Instruction (STP):</b> Set up stations in different zones (e.g., quiet reading on a couch, collaborative work at a table) and allow students to rotate based on task or preference.", "<b>Set Learning Goals (STP):</b> Encourage students to choose the space that best supports the specific learning goal they are working towards."];
    }
    insights.push({ title: 'üßë‚Äçüè´ Learner Agency & Self-Direction', affordance: agencyAffordance, moves: agencyMoves });

    let citAffordance = "The layout supports focused, deep thinking on individual tasks. Learning is structured and content-driven.";
    let citMoves = ["Pose complex, open-ended questions that require sustained individual thought before any group discussion.", "Use individual response systems (e.g., mini whiteboards, digital polls) to make every student's thinking visible."];
    if (hasAny(['whiteboard', 'writable_tv', 'vr_station'])) {
        citAffordance = "The presence of large, mobile, vertical surfaces and advanced tech tools encourages brainstorming, prototyping, and making thinking visible.";
        citMoves = ["<b>Promote Metacognition (STP):</b> Have groups map out their thinking processes or designs on whiteboards to analyze their own learning.", "<b>Pose Thought-Provoking Questions (STP):</b> Use the writable TV for a 'gallery walk' of different complex problems, where groups rotate to add to and critique the solutions of others."];
    }
    insights.push({ title: 'üí° Critical & Inventive Thinking', affordance: citAffordance, moves: citMoves });

    insightsContainer.innerHTML = '';
    insights.forEach(insight => {
        const group = document.createElement('div');
        group.className = 'insight-group';
        const movesHTML = insight.moves.map(move => `<li>${move}</li>`).join('');
        group.innerHTML = `
            <h3 class="insight-title">${insight.title}</h3>
            <p class="insight-subtitle">Affordances of this Layout</p>
            <p class="insight-text">${insight.affordance}</p>
            <p class="insight-subtitle">Suggested Pedagogical Moves (STP)</p>
            <ul class="insight-list">${movesHTML}</ul>`;
        insightsContainer.appendChild(group);
    });
  }

  // --- CHART INITIALIZATION ---
  function initializeChart() {
    const ctx = document.getElementById('spatialEffectivenessChart');
    const isDark = document.documentElement.classList.contains('dark');
    const gridColor = isDark ? 'rgba(107, 114, 128, 0.5)' : 'rgba(209, 213, 219, 1)';
    const pointLabelColor = isDark ? '#9ca3af' : '#4b5563';
    const datasetBG = isDark ? 'rgba(255, 226, 0, 0.3)' : 'rgba(0, 12, 83, 0.2)';
    const datasetBorder = isDark ? '#FFE200' : '#000C53';

    spatialChart = new Chart(ctx, {
      type: 'radar',
      data: {
        labels: ['Sightlines', 'Mobility', 'Flexibility', 'Density', 'Modality', 'Environment'],
        datasets: [{
          label: 'Effectiveness Score', data: [50, 50, 50, 50, 50, 50],
          fill: true, backgroundColor: datasetBG, borderColor: datasetBorder,
          pointBackgroundColor: datasetBorder, pointBorderColor: '#fff',
          pointHoverBackgroundColor: '#fff', pointHoverBorderColor: datasetBorder
        }]
      },
      options: {
        elements: { line: { borderWidth: 2 } },
        scales: {
          r: {
            angleLines: { color: gridColor }, grid: { color: gridColor },
            suggestedMin: 0, suggestedMax: 100,
            ticks: { display: false, stepSize: 25 },
            pointLabels: { font: { size: 11 }, color: pointLabelColor }
          }
        },
        plugins: { legend: { display: false } }
      }
    });
  }

  // --- DARK MODE ---
  function checkDarkMode() {
    if (localStorage.getItem('darkMode') === 'true') {
        toggleDarkMode.checked = true;
        document.documentElement.classList.add('dark');
    }
  }

  // --- PRESETS & SCENES ---
  function applyPreset(name, studentCount = 28){ 
    layoutRoot.innerHTML=''; clearSelection(); removeHandles(); clearGhost(); 
    const make = id => { const def = PALETTE.find(p=>p.id===id); if(!def) return null; const wrapper = document.createElementNS('http://www.w3.org/2000/svg','g'); wrapper.setAttribute('data-id', def.id); wrapper.setAttribute('data-snap', def.snap || 'none'); wrapper.style.cursor='move'; const g = document.createElementNS('http://www.w3.org/2000/svg','g'); def.draw(g,{x:0,y:0}); wrapper.appendChild(g); layoutRoot.appendChild(wrapper); makeDraggable(wrapper); return wrapper; }; 
    const place = (w,x,y,r=0)=>{ w.setAttribute('transform', `translate(${x},${y}) rotate(${r})`); };
    
    if(name==='direct'){ const tdesk = make('teacher_desk'); place(tdesk, unit*1.2, unit*3, 90); const tv = make('writable_tv'); place(tv, unit*2.8, unit*2.8, 90); const cols = 5; const rows = Math.ceil(studentCount / cols); const aisleCol = 3; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if (r * cols + c >= studentCount) break; const d=make('desk_rect'); const cx = c + (c>=aisleCol?0.4:0); place(d, unit*(6 + cx*1.3), unit*(2 + r*1.2), 90); } } }
    if(name==='pods'){ 
        const pods = Math.ceil(studentCount / 6);
        const centers = [[unit*5.0,unit*3.0],[unit*9.0,unit*3.0],[unit*13.0,unit*3.0],[unit*5.0,unit*7.5],[unit*9.0,unit*7.5],[unit*13.0,unit*7.5]]; 
        for(let i = 0; i < pods; i++) { 
            if (i >= centers.length) break; 
            const [cx, cy] = centers[i]; 
            const radius = TRI_H * 0.6; 
            for(let j=0;j<6;j++){ 
                const angle = j * 60;
                const x = cx + radius * Math.cos(rad(angle));
                const y = cy + radius * Math.sin(rad(angle));
                const tri = make('desk_tri_eq'); 
                place(tri, x, y, angle - 90); 
            } 
        } 
        const wb = make('whiteboard'); place(wb, unit*1.2, unit*1.2, 90); 
    }
    if(name==='stations'){ const wb1 = make('whiteboard'); place(wb1, unit*3, unit*1.5, 0); place(make('desk_blue'), unit*2, unit*3, 0); place(make('desk_blue'), unit*4, unit*3, 0); place(make('desk_blue'), unit*3, unit*4.5, 90); const tv2 = make('writable_tv'); place(tv2, unit*20, unit*1.5, 0); place(make('desk_green'), unit*19, unit*3, 0); place(make('desk_green'), unit*21, unit*3, 0); place(make('desk_green'), unit*20, unit*4.5, 90); const rt3 = make('group_table'); place(rt3, unit*4, unit*8.5); place(make('couch'), unit*19, unit*8.5, 0); place(make('beanbag'), unit*21.5, unit*8.0); place(make('beanbag'), unit*21.5, unit*9.0); }
    if(name==='circle'){ const cx = unit*12.0, cy = unit*6.0; const radius = Math.min(unit * 5.0, (studentCount / 18) * unit * 5.0); for(let i=0;i<studentCount;i++){ const angle = (i/studentCount)*2*Math.PI; const d = make('desk_rect'); place(d, cx + Math.cos(angle)*radius, cy + Math.sin(angle)*radius, deg(angle)+90); } const wb = make('whiteboard'); place(wb, unit*1.2, unit*2.0, 90); }
    if(name==='quiet'){ const tdesk = make('teacher_desk'); place(tdesk, unit*1.2, unit*3, 90); const cols = 5; const rows = Math.ceil(studentCount / cols); for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if (r * cols + c >= studentCount) break; const d=make('desk_rect'); place(d, unit*(4+c*1.4), unit*(1.8+r*1.2), 90); } } }
    if(name==='maker'){ const bench = make('stand_table'); place(bench, unit*3.0, unit*2.0, 90); const bench2 = make('stand_table'); place(bench2, unit*3.0, unit*4.5, 90); for(let i=0;i<8;i++){ const d=make('desk_trap'); place(d, unit*(6+i*1.0 + (i>=4?0.5:0)), unit*5.2, (i%2)*180); } const vr = make('vr_station'); place(vr, unit*11, unit*2.2, 0); }
  }

  function saveScene() {
    const name = sceneName.value.trim() || `Scene ${scenes.length+1}`; 
    const svgData = new XMLSerializer().serializeToString(layoutRoot); 
    scenes.push({name, svgData}); 
    renderScenes(); 
    sceneName.value=''; 
    flash('Scene saved');
  }

  function renderScenes(){ 
    sceneList.innerHTML=''; 
    scenes.forEach((s,idx)=>{ 
      const row = document.createElement('div'); row.className='scene-item'; 
      const input = document.createElement('input'); input.value=s.name; input.addEventListener('change', ()=>{ s.name = input.value; }); 
      const actions = document.createElement('div'); actions.className='scene-actions'; 
      const apply = document.createElement('button'); apply.className='ghost'; apply.textContent='Apply'; apply.addEventListener('click', ()=>{ layoutRoot.innerHTML = new DOMParser().parseFromString(s.svgData,'image/svg+xml').documentElement.innerHTML; [...layoutRoot.querySelectorAll('g[data-id]')].forEach(makeDraggable); clearSelection(); updateMetrics(); }); 
      const del = document.createElement('button'); del.className='danger'; del.textContent='Delete'; del.addEventListener('click', ()=>{ scenes.splice(idx,1); renderScenes(); }); 
      actions.appendChild(apply); actions.appendChild(del); 
      row.appendChild(input); row.appendChild(actions); 
      sceneList.appendChild(row); 
    }); 
  }

  // --- DRAWING & SVG HELPERS (NOW CENTERED) ---
  function deskRect(g,{w,h,base}){ const r=rect(-w/2,-h/2,w,h,base,g); r.setAttribute('filter','url(#elev)'); rect(-w/2,h/2-3,w,3,'rgba(0,0,0,0.12)',g); const gloss=rect(-w/2,-h/2,w,h,'url(#deskGrad)',g,0.5); gloss.setAttribute('pointer-events','none'); line(-w/2+2,-h/2+2,w/2-2,-h/2+2,'#111827',3,g); }
  function roundTable(g,{r,base}){ const c=circle(0,0,r,base,g); c.setAttribute('filter','url(#elev)'); stroke(c,'#111827',1); }
  function trapDesk(g,{w,h,base}){ const path = document.createElementNS('http://www.w3.org/2000/svg','path'); const inset = w*0.2; path.setAttribute('d', `M${-w/2},${-h/2} L${w/2},${-h/2} L${w/2-inset},${h/2} L${-w/2+inset},${h/2} Z`); path.setAttribute('fill', base); path.setAttribute('stroke','#111827'); path.setAttribute('stroke-width','1'); path.setAttribute('filter','url(#elev)'); g.appendChild(path); line(-w/2+2,-h/2+2,w/2-2,-h/2+2,'#111827',3,g); }
  function triDesk(g,{s,base}){ const h = TRI_H; const p = document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d', `M${-s/2},${h/2} L0,${-h/2} L${s/2},${h/2} Z`); p.setAttribute('fill', base); p.setAttribute('stroke','#111827'); p.setAttribute('stroke-width','1'); p.setAttribute('filter','url(#elev)'); g.appendChild(p); line(s*(-0.4), h/2-0.1, s*0.4, h/2-0.1, '#111827', 3, g); }
  function chair(g,{w,h}){ const c = rect(-w/2,-h/2,w,h,'#e5e7eb',g); c.setAttribute('filter','url(#elev)'); line(-w/2+2,-h/2+2,w/2-2,-h/2+2,'#111827',2,g); }
  function tv(g,{w,h}){ const b = rect(-w/2,-h/2,w,h,'#e5e7eb',g); b.setAttribute('filter','url(#elev)'); strokeRect(-w/2,-h/2,w,h,'#111827',2,g); rect(-w/2+4,-h/2+4,w-8,6,'rgba(0,0,0,0.15)',g); }
  function vr(g,{r}){ const c = circle(0,0,r,'#dbeafe',g); c.setAttribute('filter','url(#elev)'); text(0,4,'VR',g); }
  function cart(g,{w,h}){ const b = rect(-w/2,-h/2,w,h,'#e0e7ff',g); b.setAttribute('filter','url(#elev)'); text(0,4,'iPads',g); rect(-w/2,h/2-3,w,3,'rgba(0,0,0,0.15)',g); }
  function board(g,{w,h,base}){ const b = rect(-w/2,-h/2,w,h,base,g,0.22); b.setAttribute('filter','url(#elev)'); strokeRect(-w/2,-h/2,w,h,'#111827',1,g); }
  function partition(g,{w,h,base}){ rect(-w/2,-h/2,w,h,base,g,0.7).setAttribute('filter','url(#elev)'); }
  function couch(g,{w,h,base}){ const b = rect(-w/2,-h/2,w,h,base,g); b.setAttribute('filter','url(#elev)'); strokeRect(-w/2,-h/2,w,h,'#111827',1,g); rect(-w/2,h/2-3,w,3,'rgba(0,0,0,0.15)',g); }
  function beanbag(g,{r,base}){ const c = circle(0,0,r,base,g); c.setAttribute('filter','url(#elev)'); }
  function plant(g,{r}){ const c = circle(0,0,r,'#bbf7d0',g); c.setAttribute('filter','url(#elev)'); text(0,4,'üåø',g,16); }
  function zone(g,{w,h,base,label='Zone'}){ const z = rect(-w/2,-h/2,w,h,base,g,0.16); z.setAttribute('data-zone','1'); stroke(z,'#374151',1); const t = text(0,4,label,g,12); t.setAttribute('data-zone-label','1'); }
  function textLabel(g, {w, h, text: initialText}) { const bg = rect(-w/2, -h/2, w, h, 'transparent', g); bg.classList.add('text-label-bg'); const txt = text(0, 4, initialText, g, 14); txt.classList.add('text-label-text'); }
  function rect(x,y,w,h,fill,parent,alpha=1){ const el = document.createElementNS('http://www.w3.org/2000/svg','rect'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('width',w); el.setAttribute('height',h); el.setAttribute('fill',fill); if(alpha!==1) el.setAttribute('fill-opacity',alpha); el.setAttribute('stroke','#111827'); el.setAttribute('stroke-width','1'); parent.appendChild(el); return el; }
  function stroke(node,color,w=1){ node.setAttribute('stroke',color); node.setAttribute('stroke-width',w); return node; }
  function strokeRect(x,y,w,h,color,sw,parent){ const el = document.createElementNS('http://www.w3.org/2000/svg','rect'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('width',w); el.setAttribute('height',h); el.setAttribute('fill','none'); el.setAttribute('stroke',color); el.setAttribute('stroke-width',sw); parent.appendChild(el); return el; }
  function circle(cx,cy,r,fill,parent){ const el = document.createElementNS('http://www.w3.org/2000/svg','circle'); el.setAttribute('cx',cx); el.setAttribute('cy',cy); el.setAttribute('r',r); el.setAttribute('fill',fill); el.setAttribute('stroke','#111827'); el.setAttribute('stroke-width',1); parent.appendChild(el); return el; }
  function line(x1,y1,x2,y2,color,sw,parent){ const el = document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke',color); el.setAttribute('stroke-width',sw); parent.appendChild(el); return el; }
  function text(x,y,str,parent,size=12){ const el = document.createElementNS('http://www.w3.org/2000/svg','text'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('text-anchor','middle'); el.setAttribute('font-size',size); el.setAttribute('font-family','system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif'); el.textContent=str; parent.appendChild(el); return el; }
  
  // --- RESTORED & UNCHANGED FUNCTIONS ---
  function exportPNG(){ 
    const exportWidth = 1440; 
    const exportHeight = 720;
    const clone = stage.cloneNode(true); 
    clone.setAttribute('viewBox', `0 0 ${exportWidth} ${exportHeight}`); 
    clone.querySelectorAll('.selection,.handle,#ghost *,#marquee').forEach(n=>n.remove()); 
    if(!toggleLegend.checked){ const shell = clone.querySelector('#shell'); shell.querySelectorAll('text,rect#winTop1,rect#winTop2,rect#winBot1,rect#winBot2,rect#doorTopA,rect#doorTopB').forEach(n=>n.setAttribute('opacity','0')); }
    const svgData = new XMLSerializer().serializeToString(clone);
    const img = new Image(); const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'}); const url = URL.createObjectURL(svgBlob);
    img.onload = function(){ const canvas = document.createElement('canvas'); canvas.width = exportWidth; canvas.height = exportHeight; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); URL.revokeObjectURL(url); const png = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.download='classroom-layout.png'; a.href=png; a.click(); }; img.src = url; 
  }

  async function generateLayoutFromLLM() {
    const userPrompt = llmPromptEl.value;
    if (!userPrompt) {
        flash('Please describe your lesson first.');
        return;
    }

    const studentCountMatch = userPrompt.match(/\[(\d+)\]/);
    const studentCount = studentCountMatch ? parseInt(studentCountMatch[1], 10) : 32;

    llmGenerateBtn.disabled = true;
    llmGenerateBtn.textContent = 'Generating...';

    const systemPrompt = `You are an expert in spatial pedagogy. Analyze the user's lesson plan. Respond with a JSON object containing the best layout preset and operable wall configuration. The JSON must have three keys: "preset", "wall_A", and "wall_B".

    - "preset" must be one of: "direct", "pods", "stations", "circle", "quiet", "maker".
    - "wall_A" must be one of: "close", "stack".
    - "wall_B" must be one of: "close", "stack".

    Choose the preset that best matches the pedagogical activity described. Example: if the user mentions "small groups" or "collaboration", choose "pods". If "individual work", choose "quiet" or "direct". If "hands-on activities", choose "maker" or "stations".
    
    Choose wall configurations based on the need for space. If the lesson needs a large, unified space (e.g., maker activities, large circles), choose "stack" for both walls. If the lesson involves distinct groups or needs separation (e.g., stations), you might "close" one wall and "stack" the other. For focused, quiet work, "close" both walls.
    
    User prompt: "${userPrompt}"`;
    
    let chatHistory = [{ role: "user", parts: [{ text: systemPrompt }] }];
    const payload = { 
        contents: chatHistory,
        generationConfig: {
            responseMimeType: "application/json",
        }
    };
    const apiKey = "";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response:", errorBody);
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();
        
        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts.length > 0) {
            const rawJson = result.candidates[0].content.parts[0].text;
            const parsedJson = JSON.parse(rawJson);
            
            if (parsedJson.preset) {
                applyPreset(parsedJson.preset, studentCount);
                document.getElementById('presetSelect').value = parsedJson.preset;
            }
            if (parsedJson.wall_A === 'stack') {
                stackWall('A');
            } else {
                closeWall('A');
            }
            if (parsedJson.wall_B === 'stack') {
                stackWall('B');
            } else {
                closeWall('B');
            }
            flash(`Generated '${parsedJson.preset}' layout for ${studentCount} students.`);
        } else {
            console.error("Invalid response structure from AI:", result);
            throw new Error('No valid response from AI.');
        }

    } catch (error) {
        console.error("LLM Error:", error);
        flash('Sorry, an error occurred. Please check the console.');
    } finally {
        llmGenerateBtn.disabled = false;
        llmGenerateBtn.textContent = 'Generate Layout';
    }
  }

  function trySnap(g, preview){ clearGhost(); const mode = g.getAttribute('data-snap')||'none'; if(mode==='none') return; const [tx,ty] = getTranslate(g); let rot = normAngle(getRotate(g)); const step = (mode==='tri60'||mode==='edge60') ? 60 : 90; const snappedRot = Math.round(rot/step)*step; if(!rotateSelection._lastAlt && Math.abs(snappedRot-rot) <= ANGLE_HYSTERESIS) rot = snappedRot; const neighbors = [...layoutRoot.querySelectorAll('g[data-snap]')].filter(n=>n!==g); let applied=false; for(const n of neighbors){ const [nx,ny] = getTranslate(n); const dist = Math.hypot(nx-tx, ny-ty); if(dist > NEIGHBOR_RADIUS) continue; if(mode==='tri60' && n.getAttribute('data-snap')==='tri60'){ const s = TRI_S, h = TRI_H; const offsets = [ {dx:s, dy:0, a:0}, {dx:s/2, dy:h, a:60}, {dx:-s/2, dy:h, a:120}, {dx:-s, dy:0, a:180}, {dx:-s/2, dy:-h, a:240}, {dx:s/2, dy:-h, a:300} ]; for(const off of offsets){ const tx2 = nx + off.dx, ty2 = ny + off.dy; if(Math.hypot(tx2 - tx, ty2 - ty) <= SNAP_RADIUS){ if(preview){ drawGhostTri(tx2,ty2,off.a,s); } else { g.setAttribute('transform', `translate(${snap(tx2)},${snap(ty2)}) rotate(${off.a})`); } applied=true; break; } } } if(applied) break; const dx = Math.abs(nx - tx), dy = Math.abs(ny - ty); if(dx <= SNAP_RADIUS || dy <= SNAP_RADIUS){ const nx2 = dx <= SNAP_RADIUS ? nx : tx; const ny2 = dy <= SNAP_RADIUS ? ny : ty; if(preview){ drawGhostBox(nx2,ny2,g); } else { g.setAttribute('transform', `translate(${snap(nx2)},${snap(ny2)}) rotate(${rot})`); } applied=true; break; } } }
  function clearGhost(){ ghostLayer.innerHTML=''; }
  function drawGhostBox(x,y,g){ const bb = g.getBBox(); const r = document.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('x', x + bb.x); r.setAttribute('y', y + bb.y); r.setAttribute('width', bb.width); r.setAttribute('height', bb.height); r.setAttribute('class','ghost-snap'); ghostLayer.appendChild(r); }
  function drawGhostTri(cx,cy,angle,s){ const h = Math.sin(Math.PI/3)*s; const pts = [[-s/2,h/2],[0,-h/2],[s/2,h/2]].map(([px,py])=>{ const rx = Math.cos(rad(angle))*px - Math.sin(rad(angle))*py + cx; const ry = Math.sin(rad(angle))*px + Math.cos(rad(angle))*py + cy; return [rx,ry]; }); const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d', `M${pts[0][0]},${pts[0][1]} L${pts[1][0]},${pts[1][1]} L${pts[2][0]},${pts[2][1]} Z`); path.setAttribute('class','ghost-snap'); ghostLayer.appendChild(path); }
  
  let activeHandle = null;
  function showHandles(g){ g.querySelectorAll('.handle').forEach(n=>n.remove()); const bb = g.getBBox(); const corners = [ {name:'nw', x:bb.x, y:bb.y}, {name:'ne', x:bb.x+bb.width, y:bb.y}, {name:'se', x:bb.x+bb.width, y:bb.y+bb.height}, {name:'sw', x:bb.x, y:bb.y+bb.height} ]; for(const c of corners){ const h = document.createElementNS('http://www.w3.org/2000/svg','rect'); h.classList.add('handle'); h.setAttribute('data-handle', c.name); h.setAttribute('x', c.x-6); h.setAttribute('y', c.y-6); h.setAttribute('width', 12); h.setAttribute('height', 12); h.setAttribute('fill', 'var(--accent)'); h.setAttribute('opacity','0.85'); h.style.cursor = `${c.name}-resize`; h.addEventListener('pointerdown', (e)=> startResize(e,g,h)); g.appendChild(h); } }
  function removeHandles(){ layoutRoot.querySelectorAll('.handle').forEach(n=>n.remove()); }
  function startResize(e, g, handle){ 
    e.stopPropagation(); 
    activeHandle = handle.getAttribute('data-handle'); 
    handle.setPointerCapture(e.pointerId); 
    const start = getMouseSVG(e); 
    // **FIX:** More robust selector for the resizable rectangle
    const nodeToResize = g.querySelector('rect:not(.handle)'); 
    if(!nodeToResize) return; 
    const startBox = { x:+nodeToResize.getAttribute('x'), y:+nodeToResize.getAttribute('y'), w:+nodeToResize.getAttribute('width'), h:+nodeToResize.getAttribute('height') }; 
    const min = unit; 
    const onMove = ev=>{ const cur = getMouseSVG(ev); const dx = cur.x - start.x; const dy = cur.y - start.y; const bypass = ev.altKey || !toggleSnap.checked; let x = startBox.x, y = startBox.y, w = startBox.w, h = startBox.h; if(activeHandle.includes('n')){ const newY = (bypass? startBox.y + dy : snap(startBox.y + dy)); h = startBox.h + (startBox.y - newY); y = newY; } if(activeHandle.includes('s')){ h = (bypass? startBox.h + dy : snap(startBox.h + dy)); } if(activeHandle.includes('w')){ const newX = (bypass? startBox.x + dx : snap(startBox.x + dx)); w = startBox.w + (startBox.x - newX); x = newX; } if(activeHandle.includes('e')){ w = (bypass? startBox.w + dx : snap(startBox.w + dx)); } if(w < min){ const diff = min - w; if(activeHandle.includes('w')) x -= diff; w = min; } if(h < min){ const diff = min - h; if(activeHandle.includes('n')) y -= diff; h = min; } nodeToResize.setAttribute('x', x); nodeToResize.setAttribute('y', y); nodeToResize.setAttribute('width', w); nodeToResize.setAttribute('height', h); const label = g.querySelector('text[data-zone-label], text.text-label-text'); if(label){ label.setAttribute('x', 0); label.setAttribute('y', 4); } itemsLayer.querySelectorAll('.selection').forEach(n=>n.remove()); showHandles(g); }; 
    const onUp = ev=>{ try{ handle.releasePointerCapture(ev.pointerId);}catch(_){ } stage.removeEventListener('pointermove', onMove); stage.removeEventListener('pointerup', onUp); drawSelection(); updateMetrics(); }; 
    stage.addEventListener('pointermove', onMove); 
    stage.addEventListener('pointerup', onUp); 
  }
  function editTextLabel(e) {
    const g = e.currentTarget;
    const textEl = g.querySelector('.text-label-text');
    const bgRect = g.querySelector('.text-label-bg');
    const { width, height } = bgRect.getBBox();

    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
    foreignObject.setAttribute('x', bgRect.getAttribute('x'));
    foreignObject.setAttribute('y', bgRect.getAttribute('y'));
    foreignObject.setAttribute('width', width);
    foreignObject.setAttribute('height', height);
    foreignObject.classList.add('text-edit-foreign-object');

    const textarea = document.createElement('textarea');
    textarea.value = textEl.textContent;
    textarea.classList.add('text-edit-textarea');
    
    foreignObject.appendChild(textarea);
    g.appendChild(foreignObject);
    
    textarea.focus();
    textarea.select();

    textEl.style.display = 'none';

    const finishEditing = () => {
        textEl.textContent = textarea.value;
        g.removeChild(foreignObject);
        textEl.style.display = 'block';
        updateMetrics();
    };

    textarea.addEventListener('blur', finishEditing);
    textarea.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' && !ev.shiftKey) {
            ev.preventDefault();
            finishEditing();
        }
    });
  }
  
  // --- RUN APP ---
  initializeApp();
})();
</script>
</body>
</html>
